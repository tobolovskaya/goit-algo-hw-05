# -*- coding: utf-8 -*-
"""ДЗ5_Тоболовська Євгенія.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NDwGS0tbHhn8dBThFqdGHeFvoZArIsYS

Завдання 1
"""

class HashTable:
    # ... Інші частини класу HashTable ...

    def delete(self, key):
        """Видаляє пару ключ-значення за заданим ключем."""
        hash_key = self._hash_function(key)
        key_exists = False
        bucket = self.array[hash_key]
        for i, kv in enumerate(bucket):
            k, v = kv
            if key == k:
                key_exists = True
                break
        if key_exists:
            del bucket[i]
            print(f"Пара ключ-значення для ключа '{key}' видалена.")
        else:
            print(f"Ключ '{key}' не знайдено.")

    # ... Решта методів класу HashTable ...

"""Завдання 2"""

def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    iterations = 0
    upper_bound = None

    while left <= right:
        iterations += 1
        mid = left + (right - left) // 2
        mid_value = arr[mid]

        if mid_value == target:
            # Знайдено точне значення, верхня межа знайдена
            upper_bound = mid_value
            break
        elif mid_value < target:
            left = mid + 1
        else:
            right = mid - 1
            upper_bound = mid_value  # Поточне значення є потенційною верхньою межею

    # Якщо верхня межа не знайдена, значить всі елементи менші за цільове значення
    if upper_bound is None:
        upper_bound = -1  # Або встановлюємо інше значення, що вказує на відсутність верхньої межі

    return (iterations, upper_bound)

# Тестування функції
sorted_array = [0.5, 1.2, 1.5, 2.3, 3.6, 4.1, 5.8]
target_value = 2.5
binary_search(sorted_array, target_value)

"""Завдання 3

Алгоритм Кнута-Морріса-Пратта (КМП)
"""

def KMPSearch(pat, txt):
    M = len(pat)
    N = len(txt)
    lps = [0]*M
    j = 0 # index for pat[]
    computeLPSArray(pat, M, lps)
    i = 0 # index for txt[]
    while i < N:
        if pat[j] == txt[i]:
            i += 1
            j += 1
        if j == M:
            print("Found pattern at index " + str(i-j))
            j = lps[j-1]
        elif i < N and pat[j] != txt[i]:
            if j != 0:
                j = lps[j-1]
            else:
                i += 1

def computeLPSArray(pat, M, lps):
    len = 0 # length of the previous longest prefix suffix
    lps[0] = 0 # lps[0] is always 0
    i = 1
    while i < M:
        if pat[i]== pat[len]:
            len += 1
            lps[i] = len
            i += 1
        else:
            if len != 0:
                len = lps[len-1]
            else:
                lps[i] = 0
                i += 1

"""Алгоритм Боєра-Мура"""

def badCharHeuristic(string, size):
    badChar = [-1]*256
    for i in range(size):
        badChar[ord(string[i])] = i;
    return badChar

def search(txt, pat):
    m = len(pat)
    n = len(txt)
    badChar = badCharHeuristic(pat, m)
    s = 0
    while(s <= n-m):
        j = m-1
        while j>=0 and pat[j] == txt[s+j]:
            j -= 1
        if j<0:
            print("Pattern occur at shift = {}".format(s))
            s += (m-badChar[ord(txt[s+m])] if s+m<n else 1)
        else:
            s += max(1, j-badChar[ord(txt[s+j])])

"""Алгоритм Рабіна-Карпа"""

def rabinKarp(pat, txt, q):
    M = len(pat)
    N = len(txt)
    i = 0
    j = 0
    p = 0    # hash value for pattern
    t = 0    # hash value for txt
    h = 1
    d = 256
    for i in range(M-1):
        h = (h*d)%q
    for i in range(M):
        p = (d*p + ord(pat[i]))%q
        t = (d*t + ord(txt[i]))%q
    for i in range(N-M+1):
        if p==t:
            for j in range(M):
                if txt[i+j] != pat[j]:
                    break
            j+=1
            if j==M:
                print("Pattern found at index " + str(i))
        if i < N-M:
            t = (d*(t-ord(txt[i])*h) + ord(txt[i+M]))%q
            if t < 0:
                t = t+q

"""Вимірювання ефективності"""

import timeit

# Завантажте ваш текст
text = "your_text_here"
pattern1 = "existing_substring"
pattern2 = "non_existing_substring"

# Виміряйте час
print(timeit.timeit(lambda: KMPSearch(pattern1, text), number=1000))
print(timeit.timeit(lambda: KMPSearch(pattern2, text), number=1000))

"""Висновки

Після аналізу даних ви зможете визначити, який алгоритм є найшвидшим для кожного виду текстів та підрядків. Врахуйте, що ефективність може відрізнятися в залежності від конкретних умов. Зробіть висновки у форматі Markdown, описуючи ваші спостереження та аналіз.
"""
# -*- coding: utf-8 -*-
"""ДЗ5_Тоболовська Євгенія.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NDwGS0tbHhn8dBThFqdGHeFvoZArIsYS

Завдання 1
"""

class HashTable:
    # ... Інші частини класу HashTable ...

    def delete(self, key):
        """Видаляє пару ключ-значення за заданим ключем."""
        hash_key = self._hash_function(key)
        key_exists = False
        bucket = self.array[hash_key]
        for i, kv in enumerate(bucket):
            k, v = kv
            if key == k:
                key_exists = True
                break
        if key_exists:
            del bucket[i]
            print(f"Пара ключ-значення для ключа '{key}' видалена.")
        else:
            print(f"Ключ '{key}' не знайдено.")

    # ... Решта методів класу HashTable ...

"""Завдання 2"""

def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    iterations = 0
    upper_bound = None

    while left <= right:
        iterations += 1
        mid = left + (right - left) // 2
        mid_value = arr[mid]

        if mid_value == target:
            # Знайдено точне значення, верхня межа знайдена
            upper_bound = mid_value
            break
        elif mid_value < target:
            left = mid + 1
        else:
            right = mid - 1
            upper_bound = mid_value  # Поточне значення є потенційною верхньою межею

    # Якщо верхня межа не знайдена, значить всі елементи менші за цільове значення
    if upper_bound is None:
        upper_bound = -1  # Або встановлюємо інше значення, що вказує на відсутність верхньої межі

    return (iterations, upper_bound)

# Тестування функції
sorted_array = [0.5, 1.2, 1.5, 2.3, 3.6, 4.1, 5.8]
target_value = 2.5
binary_search(sorted_array, target_value)

"""Завдання 3

Алгоритм Кнута-Морріса-Пратта (КМП)
"""

def KMP_search(pattern, text):
    # Реалізація КМП
    pass

"""Алгоритм Боєра-Мура"""

def Boyer_Moore_search(pattern, text):
    # Реалізація Боєра-Мура
    pass

"""Алгоритм Рабіна-Карпа"""

def Rabin_Karp_search(pattern, text):
    # Реалізація Рабіна-Карпа
    pass

"""Вимірювання часу виконання"""

import timeit

# Припустимо, text і pattern вже визначені
setup = '''
text = "Текстовий рядок..."
pattern = "шуканий підрядок"
from __main__ import KMP_search
'''

print(timeit.timeit('KMP_search(pattern, text)', setup=setup, number=1000))

"""Зчитування тексту з файлів"""

def read_text_from_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        return file.read()

text_article1 = read_text_from_file('path_to_article1.txt')
text_article2 = read_text_from_file('path_to_article2.txt')

"""Визначення підрядків для пошуку"""

existing_substring = "існуючий підрядок"  # Існує в тексті
non_existing_substring = "нісенітниця"  # Не існує в тексті

"""Вимірювання часу виконання алгоритмів"""

import timeit

def measure_time(func, *args):
    start_time = timeit.default_timer()
    func(*args)
    end_time = timeit.default_timer()
    return end_time - start_time

# Приклад вимірювання
time_kmp_existing = measure_time(knuth_morris_pratt_search, text_article1, existing_substring)
time_kmp_non_existing = measure_time(knuth_morris_pratt_search, text_article1, non_existing_substring)

"""Висновки:

На основі отриманих даних зробіть висновки щодо швидкостей алгоритмів для кожного тексту окремо та в цілому. Враховуйте, як алгоритми справляються з реальними та вигаданими підрядками.

Ці кроки допоможуть вам організовано виконати завдання і надати звіт у відповідності до критеріїв прийняття. Врахуйте, що приклади коду вище є загальними шаблонами і потребують вашої адаптації до конкретних умов завдання та власних алгоритмів пошуку.
"""